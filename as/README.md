# Assembler
Assembler for the TRASM toolchain. Takes in a source file and assembles it into an object file, including relocations and symbol table. If multiple source files are provided, they will be concatenate together in the order they were passed in.

## Usage
```
as [-vg] source.s ...
```
| Option | Description |
| ------ | ----------- |
| -v     | Verbose output, will display version information, and how many bytes the assembly would consume if it were ran on Z80 hardware |
| -g     | All routine labels will automatically be made global and included the object symbol table |

## Instructions
As mentioned, the assembler is capable of assembling all Z80 instructions, both documented and undocumented. For undocumented instruction syntax, the following website was used as a reference.

https://clrhome.org/table/
## Symbols
Symbol definition follows the syntax used in Version 6 UNIX. Unlike most Z80 assemblers, the `equ` directive is not used. All symbols can also be redefined as many times as needed, thought this isn't recommended for labels as it may make the final product confusing to read. Symbols are limited to 8 characters to save memory. If a symbol is longer than 8 characters, the other characters will be ignored. The following code example will show off some simple symbol definitions:
```
; basic symbol definition, sym_1 is absolute
sym_1 = 0

; label symbol, label_1 is in whatever segment was currently selected
label_1:

; label generated by defl
; similar to a standard label, but label_2 will inherit the defined type
.defl byte label_2 0, 1, 2

; local symbol, consumes less memory than a standard symbol
; only 0-9 are valid
; when addressed, 'b' or 'f' must be specified for the assembler to search forward or backwards for the local symbol
1:
  jp 1b
```

## Directives
A small number of directives are included in the assembler to make configuration and data generation easier

| Directive | Description |
| --------------------------- | ------- |
| `.def (type)[#] exp1, exp2, ...` | Directly defines data, based on the type. Each element of the definition will take the size of the type, zero padding if needed. A set of square brackets after the type can be used to identify a set number of elements to be created |
| `.defl (type)[#] (name) exp, ...` | Same as `def`, but will create a label with the defined type |
